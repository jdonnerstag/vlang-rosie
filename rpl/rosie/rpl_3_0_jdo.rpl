---- -*- Mode: rpl; -*-
---- vim:syn=rosie
----
---- rpl_3_0_jdo.rpl   Grammar for RPL itself, written in RPL version 3
----
---- Â© Copyright Juergen Donnerstag 2021.
---- LICENSE: MIT License (https://opensource.org/licenses/mit-license.html)
---- AUTHOR: Juergen Donnerstag

package rpl_3_0

alias ws = [ \t\r]+
alias newline = "\n"
alias comment = "--" find:newline / $
alias atmos = ws? (comment / newline)* ws?		    -- "atmosphere"
-- TODO atmos is so heavily used everywhere that it would be nice, if we could weave in user provided V-code

alias id_char = [:alnum:] / [_]
alias id = [:alpha:] id_char*

alias dot = "."
alias unoverloaded_id_symbol = [$~\^]
alias id_symbol = dot / unoverloaded_id_symbol

-- It is important that an error consumes at least one character here. As a
-- tactic for continuing to parse after an error, we will skip to eol and try
-- to continue.
alias rest_of_line = (!newline .)+ newline / $
syntax_error = rest_of_line

alias localname = unoverloaded_id_symbol / (dot !id) / (id !dot)
packagename = id
identifier = {id [.]}? localname

-- During parsing, we enforce two rules about string literals: ESC must be
-- followed by another character, and a double quote (inside the literal) must
-- be escaped.  Further interpretation of the literal occurs during
-- compilation.
alias dquote = ["]					    -- "
alias esc =    [\\]
literal = ((!(esc / dquote) .) / (esc .))*
alias quoted_string = dquote literal dquote

alias hash_mark = [#]
tag = localname
hash_exp = hash_mark (tag / quoted_string)

alias star =     [*]
alias question = [?]
alias plus =     [+]
end_token = "end"
alias keyword = "local" / "alias" / "let" / "grammar" / "in" / "end" / "bultin"
modifier = "local" / "alias" / "builtin"

-- Two rules are enforced for all character sets during parsing: ESC must be
-- followed by another character; an open or close bracket (inside the character
-- set) must be escaped.
-- At parse time, the only difference between a range and a list is that a range
-- will have an unescaped dash in it.
-- Further interpretation occurs at compile time for the contents of a character
-- list, the ends of a character range, and the name of a named set.
complement = "^"
alias character = (!esc !"[" !"]" .) / (esc .)
charlist = (!"]" character)*
named_charset = [A-Za-z]+
-- TODO replace [:^space] with [^:space:]
simple_charset = "[" complement? ((":" named_charset ":") / charlist) "]"

low =  [0-9]*				    -- an int or nothing
high = [0-9]*
alias repetition = "{" ws? low ws? ("," ws? high ws? )? "}"		-- TODO Allow to redefine ~ without \r\n

quantifier = star / question / plus / repetition

alias slash =   [/]
alias and =     [&]
open =          [(]
openraw =       [{]
openbracket =   [\[]
close =         [)]
closeraw =      [}]
closebracket =  [\]]

alias negation =   [!]
alias lookahead =  [>]
alias lookbehind = [<]
predicate = (negation / lookahead / lookbehind)+

-- 1. allow sequences of one expression
-- 2. parse infix expressions as a sequence of terms and operators
-- 3. fix up the parse tree when converting to AST

operator = (slash / and)

macro_end = ws?

-- TODO I wish there would be an option to make all "childs" an alias,
-- so that they don't create excessive captures. May be no_capture:{..}
assignment_prefix = keyword / ((~ modifier ~)* identifier ws? "=")

-- grammar
alias exp = predicate? term quantifier?
alias term = cooked / raw / quoted_string / simple_charset / bracket / hash_exp / macro / identifier
macro = identifier ":" term macro_end
alias cooked = open atmos right_hand atmos close
alias raw = openraw atmos right_hand atmos closeraw
alias bracket = openbracket complement? atmos right_hand atmos closebracket

-- binding forms
alias empty = [;]
alias simple = (~ modifier ~)* identifier ws? "=" atmos right_hand
alias bindings = binding+
in_kw = "in"
grammar_block_1 = bindings atmos in_kw atmos bindings
grammar_block_2 = bindings
alias grammar_block = "grammar" atmos (grammar_block_1 / grammar_block_2) atmos end_token
-- ;in
alias statement = grammar_block / binding / syntax_error
alias right_hand = exp (atmos no_capture:(!assignment_prefix) atmos operator? atmos exp)*
recursive binding = (simple / empty) atmos
-- end

major = [0-9]{1,3}
minor = [0-9]{1,3}
alias version_spec = major "." minor

alias fpath = id ("/" id)*
importpath = quoted_string / fpath	  -- double quoted, interpreted, pattern name is "literal"
alias import_spec = atmos importpath (~ "as" ~ (packagename / dot))?

----------------------------------------------------------------------------------------
-- Top level patterns
----------------------------------------------------------------------------------------

language_decl = "rpl" ws version_spec ws? ";"? atmos
package_decl = "package" ws packagename ws? ";"? atmos
alias import_decl = "import" import_spec ("," atmos import_spec)* (ws? ";"? atmos)

-- RPL module structure:
alias import_decls = (import_decl atmos)*
alias statements = (statement atmos)*
-- TODO Now that we support multiple entrypoints, we may stops after the (optional) language_decl.
--   Which would allow us to switch the parser if needed
-- TODO For the same reason, we may have a 3rd pattern for the final expression.
pub rpl_module = (atmos language_decl? package_decl? import_decls statements $) / syntax_error

-- Command line and regex like expressions
main = right_hand
-- TODO replace binding* with statements ??
pub rpl_expression = ((import_decls binding* main? atmos) / atmos) $ / syntax_error

---------------------------------------------------------------------------------------------------
-- Tests
---------------------------------------------------------------------------------------------------

-- test language_decl rejects "rpl", "rpl ", "rpl a", "rpl 1.a", "rpl 1.", "rpl 1.1234", "rpl 1.\n1"
-- test language_decl accepts "rpl 0.0", "rpl 1.0\n", "rpl 52.99", "rpl 99.99", "rpl 1.1 -- Comment\n"

-- test package_decl accepts "package foo", "package fooBar", "package f_oo"
-- test package_decl rejects "package", "package _foo", "package 6foo", "package .foo", "package foo.bar"
-- test package_decl rejects "package \n foo"

-- test import_decl rejects "import"

-- importpath can be QUOTED STRING:
-- test import_decl rejects "import \"foo/bar\","
-- test import_decl accepts "import \"foo/bar\""
-- test import_decl accepts "import \"foo/bar\", \"/usr/local/baz\", \"/usr/bin/time\""
-- test import_decl accepts "import \"foo/bar\" as foo"
-- test import_decl accepts "import \"foo/bar\" as foo, \"/usr/local/baz\", \"/usr/bin/time\""
-- test import_decl accepts "import \"foo/bar\" as foo, \"/usr/local/baz\" as ., \"/usr/bin/time\""

-- importpath can be PLAIN SYMBOL, uninterpreted:
--    (But a path must be relative, and a symbol starts with [:alpha:])
-- test import_decl rejects "import foo,"
-- test import_decl rejects "import foo["
-- test import_decl accepts "import foo/bar/baz"
-- test import_decl accepts "import foo/bar", usr/lo-cal/b_az, \"/usr/bin/time\""
-- test import_decl accepts "import foo/bar as foo"
-- test import_decl accepts "import foo/bar as foo, \"/usr/local/baz\", bin/time"
-- test import_decl accepts "import f_o_o as foo, local/baz as ., bin/time"
-- test import_decl accepts "import f_o_o/bar as foo, \"/usr/local/baz\" as ., \"/usr/bin/time\""

-- test rpl_expression accepts "foo_1:x", "pkg.f:x", "f:\"hello\"", "f:!x", "f:x+", "f:(x y z)", "f:{!x}", "f:{x y z}"
-- test rpl_expression accepts "f:(x, y)", "foo:{a, b}"
-- test rpl_expression accepts "f:(a, 55)", "foo.bar:(1, 2, 3, a b c, d / e, {f}*)", "f:{a / b, 3}+"
-- Jdo: removed support for 'functions'
-- x test rpl_expression rejects "f:", "pkg.f:"
-- # test rpl_expression includes form.arglist "f:(x, y)", "f:(3)"
-- test rpl_expression excludes form.arglist "f:(x y)"
-- # test rpl_expression includes form.arg "f:(x)", f:(x y)", "f:x", "f:5", "f:{x y}", "f:{x}",
-- # test rpl_expression includes form.arg "f:{a / b}+", "f:{(a)}", "f:{[:set:]}"
-- # test rpl_expression includes form.rawarglist "f:{5}", "f:{7, x, a / b / c+}", "f:{(a),b}", "f:{[:set:]{1,2},\"hi\"}"
