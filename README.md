# Native [Rosie-RPL](https://rosie-lang.org/) implementation in [V-lang](https://vlang.io)

[Rosie](https://rosie-lang.org/) is a pattern language (RPL for short), a little like
regex, but aiming to solve some of the regex issues. All credits to Jamie A. Jennings
and her team for all the great work.

This project (V implementation of Rosie-lang) is work in progress (not even alpha).

Very similar to a compiler, it requires
- A core 0 parser, which is able to parse rpl input into an AST
- A compiler backend, which converts the AST into virtual machine byte code
- A virtual machine runtime, able execute the byte code instructions and match input against the pattern
- A (better) parser, that leverages the virtual machine runtime to parse the RPL pattern
- May be an additional compiler backend that generates V code instead

Additional objectives are:
- Be compliant with the RPL Language Reference
- As easy and intuitive to use in V-lang based projects
- A REPL to test and debug rpl pattern easily
- Jamie's implementation has nice support for grep-like search, colored output, and also tree-like output
  to review details of the AST.

So far only the virtual machine and the core 0 parser have been implemented.

The project started with a tiny virtual machine, able to load and execute '\*.rplx' files
(compiled RPL code), generated by Rosie's original compiler. It seems to be working,
but is not yet battle tested.

Even though the implementation is able to read '\*.rplx' files, it is not designed to replace
Rosie's original implementation. The V module does not expose the same library
functions and signatures.

Please note that the '\*.rplx' file structure and neither the byte codes of the virtual
machine are part of Rosie's specification and thus are subject to change without
formal notice from the Rosie team.

This project started as a proof-of-concept aiming at getting pratical experience with V and validate it's promises.

I decided to use Rosie because I like many of it's ideas, and thought it would be a good contributions to V as well.

Obviously I needed to start somewhere, and I decided to start with the RPL runtime. The original RPL runtime is completely written in C, whereas the compiler and frontend is a mixture of C and Lua. The V implementation started as copy of the C-code, gradually introducing more and more V constructs, and also replacing 'unsafe' pointer arithmetics. V's C-to-V translator
has not been available yet, hence I translated the code manually and then restructured it and introduced V-lang constructs.

I've not yet done any performance tests or benchmarks. That is on my todo list. The current implementation is not performance tuned yet. It will be interesting to see, how it compares to the original one.

The RPL compiler has an experimental feature to compile '\*.rpl' source code files into '*.rplx' files. Which allowed me to leverage RPL's standard frontend and compiler, but my own runtime.

Current status of the runtime is alpha. Even though I keep on adding test cases, there are for sure plenty edge cases which have not been tested yet and may fail.

Recently I added an RPL parser able to read and parse RPL source code into an AST (intermediate representation). It
successfully is able to read all '\*.rpl' files provided by Rosie, including the rpl files implementing the RPL language
specification itself. It is pre-alpha right now.

Next step will be to implement an initial compiler backend, which reads the AST and generates the byte-code instructions for
the virtual machine.

As mentioned, this project started as PoC to practically test and gain some experience with V-lang. Despite some rough edges
here and there, so far I'm actually pleased. See (here)[https://github.com/jdonnerstag/vlang-lessons-learnt/wiki] for my very own FAQ and "things to remember" list. I find the V-code much easier to read and maintain then comparable C-code. Compiler
speed is definitely a plus as well, allowing for quick code-test cycles. Occassionaly I wish a V-interpreter or -debugger
would already be available, to help me find and fix issues. For now, printing debug messages must suffice.
