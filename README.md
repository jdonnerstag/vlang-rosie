# Native [Rosie-RPL](https://rosie-lang.org/) implementation in [V-lang](https://vlang.io)

[Rosie](https://rosie-lang.org/) is a pattern language (RPL for short), a little like
regex, but aiming to solve several of the regex issues. All credits to Jamie A. Jennings
and her team for a great job.

This project (native V-lang implementation of RPL) is work in progress (alpha, may be beta),
but ready to be tested in the field. APIs may still change, CLIs and a REPL are yet to be implemented.
It is fully functional: it parses and compiles all files in Jamie's RPL libary (./rpl), including
the rpl files to parse RPL code, and it successfully executes all (inline) unittests in this files.

Very similar to a compiler, the project consists of the following modules:
- A core 0 parser, written in V, which is able to parse rpl input into an AST
- A compiler backend, which converts the AST into virtual machine byte code
- A virtual machine runtime, able to execute the byte code instructions and match input against the pattern

Not yet available:
- A (better) parser, that leverages the RPL virtual machine to parse RPL pattern
- Possibly an additional compiler backend that generates native V code instead

Project objectives are:
- Be compliant with the RPL Language Reference
- Easy and intuitive to use in any V-lang project
- A REPL to test and debug rpl pattern easily
- Jamie's implementation has nice support for grep-like search, colored output, and also tree-like output
  to review details of the AST. We'd like to reach a similar level of user comfort.
- Integration with other lanugages such as Python, Julia, C/C++, Rust, Java, JavaScript, etc.
  The more popular languages are supported, the better.
- A Visual-Code Studio plugin would be nice. Syntax highligting for rpl files, readonly view of
  disassembled rplx files, compile rpl files upon save or manually triggered, automatically run
  unittest, etc..

The project started with a tiny virtual machine, able to load and execute '\*.rplx' files
(compiled RPL code), generated by Rosie's original compiler. It is working, but is not battle tested.
By now, the virtual machine evolved a little and is not no longer compatible. We are
still able to read and execute '\*.rplx' files, we'll not put more effort into it.

Even though the implementation is able to read '\*.rplx' files, it is not designed to replace
Rosie's original runtime . The V module does not expose the same library functions and signatures.

Please note that the '\*.rplx' file structure and neither the byte codes of the virtual
machine are part of Rosie's specification and thus are subject to change without
formal notice from the Rosie team.

This project started as a proof-of-concept aiming at getting pratical experience with V
and validate it's promises.

I decided to use Rosie because I like many of it's ideas, and thought it would be a good
contributions to V as well.

Obviously I needed to start somewhere, and I decided to start with the RPL runtime. The original
RPL runtime is completely written in C, whereas the compiler and frontend is a mixture of C and Lua.
The V implementation started as copy of the C-code, gradually introducing more and more V constructs,
and also replacing 'unsafe' pointer arithmetics. V's C-to-V translator was not been available yet,
hence I translated the code manually and then restructured it and introduced V-lang constructs.

I've not yet done any performance tests or benchmarks. That is on my todo list. The current implementation
is not performance tuned yet. It will be interesting to see, how it compares to the original one.

Jamie's RPL compiler has an experimental feature to compile '\*.rpl' source code files into '*.rplx' files.
Which allowed me to leverage RPL's standard frontend and compiler, but execute in my own runtime.

Then I've added an RPL parser able to read and parse RPL source code into an AST (intermediate representation). It
successfully is able to read all '\*.rpl' files provided by Rosie, including the rpl files implementing the RPL language
specification itself.

And now we also have a compiler, which generates RPL-VM byte code instructions, which can be executed
by the evolved runtime. Evolved runtime, because it is no longer compatible with Rosie's original one.

As mentioned, this project started as PoC to practically test and gain some experience with V-lang.
Despite some rough edges here and there, so far I'm mostly pleased. See [here](https://github.com/jdonnerstag/vlang-lessons-learnt/wiki)
for my very own FAQ and "things to remember" list. I find the V-code much easier to read and maintain
then comparable C-code. Compiler speed is definitely a plus as well, allowing for quick code-test cycles.
Occassionaly I wish a V-interpreter or -debugger would already be available, to help me find and fix
issues. For now, adding and removing debug messages is what I do.
