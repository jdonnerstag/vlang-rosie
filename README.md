# Native [V-lang](https://vlang.io) implementation of [Rosie-RPL](https://rosie-lang.org/)

[Rosie](https://rosie-lang.org/) is a pattern language (RPL for short). A little bit like
regex, but aiming to solve several of the regex issues. All credits to Jamie A. Jennings
and her team for this job.

This project (native V-lang implementation of RPL) is work in progress (alpha, may be beta),
but ready to be tested in the field. APIs may still change, CLI is work-in-progress, and a REPL
is on the todo list.
The current version is fully functional: it parses and compiles all files in Jamie's RPL libary (./rpl), including
the rpl files to parse RPL code, and it successfully executes all (inline) unittests in this folder.

Very similar to a compiler, the project consists of the following modules:
- A core 0 parser, written in V, which is able to parse rpl input into an AST
- A compiler backend, which converts the AST into virtual machine byte code
- A virtual machine runtime, able to execute the byte code instructions and match input against the pattern

Not yet available:
- A (better) parser, that leverages the RPL virtual machine to parse RPL pattern
- Possibly an additional compiler backend that generates native V code


# Project objectives

- Be compliant with the RPL Language Reference
- Easy and intuitive to use in any V-lang project
- A REPL to test and debug rpl pattern easily
- Jamie's implementation has nice support for grep-like search, colored output, and also tree-like output
  to review details of the AST. I'd like to reach at least a similar level of user support.
- Integration with other lanugages such as Python, Julia, C/C++, Rust, Java, JavaScript, etc.
  The more popular languages are supported, the better.  (I wish V-lang already had a python interface)
- A Visual-Code Studio plugin would be nice. Syntax highligting for rpl files, readonly view of
  disassembled rplx files, compile rpl files upon save or manually triggered, automatically run
  unittest, etc..


# A bit of history

The project started with a tiny virtual machine (v1), able to load and execute '\*.rplx' files
(compiled RPL code), generated by Rosie's original compiler. It is working, but is not battle tested.
By now, the virtual machine evolved (v2) a little and is not no longer backwards compatible. We are
still able to read and execute '\*.rplx' files, but we'll not put more effort into it.

Even though the implementation is able to read '\*.rplx' files, it was not designed to replace
Rosie's original runtime. The V module does not expose the same library functions and signatures.
Instead it was a nice starting point for a native V-lang implementation, as it allowed us to test the
new runtime, but re-use the original parser and compiler to generate the '\*.rplx' files.

Please note that neither the '\*.rplx' file structure nor the byte codes of the virtual
machine are part of Rosie's specification and thus are subject to change without
formal notice from the Rosie team.

Originally this project was a proof-of-concept aiming at getting pratical experience with V
and validate it's promises. I decided to use Rosie because I like many of it's ideas, and thought
it would be a good contributions to V as well.

Obviously I needed to start somewhere, and I decided to start with the RPL runtime. The original
RPL runtime is completely written in C, whereas the compiler and frontend is a mixture of C and Lua.
The V implementation started as copy of the C-code, gradually introducing more and more V constructs,
and also replacing 'unsafe' pointer arithmetics. V's C-to-V translator was not yet available,
hence I translated and reengineered the code manually.

I've not yet done any performance tests or benchmarks. That is on my todo list. It will be interesting
to see, how it compares to the original one.

Meanwhile I've added an RPL parser (written in V) able to read and parse RPL source code into an
AST (intermediate representation). It successfully reads all '\*.rpl' files provided in Rosie's library,
including the rpl files implementing the RPL language specification itself.

On my todo list is a RPL parser, that leverages the RPL runtime to parse RPL. The core 0 parser would
only be needed to bootstrap the RPL based parser.

By now also a first compiler exists. One that generates RPL-VM byte code instructions (v2). It doesn't
exist right now though. Modifying the v2 compiler to generate v1 compliant byte code and write `\*.rplx`
files, would certainly be possible with some effort.

As mentioned, this project started as PoC to practically test and gain some experience with V-lang.
Despite some rough edges here and there, so far I'm mostly pleased. See [here](https://github.com/jdonnerstag/vlang-lessons-learnt/wiki)
for my very own FAQ and "things to remember" list. I find the V-code much easier to read and maintain
then comparable C-code. Compiler speed is definitely a plus as well, allowing for quick code-test cycles.
Occassionaly I wish a V-interpreter or -debugger would already be available, to help me find and fix
issues. For now, adding and removing debug messages is what I do (and why V built time is so important).
