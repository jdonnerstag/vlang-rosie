module compiler_backend_vm

import rosie.runtime as rt
import rosie.parser

//
// Please see ./modules/rosie/disassembler for an executable to disassemble *.rplx file.
// The files in ./modules/runtime/test_data/*.rplx have been compiled with rosie's
// original compiler, and we used them as starting point for the instructions to be
// generated by the compiler backend.
//

fn parse_and_compile(rpl string, debug int) ? Compiler {
	mut p := parser.new_parser(data: rpl, debug: debug)?
	p.parse_binding(0)?
	mut c := new_compiler(p)
	c.compile("*")?
	return c
}

fn test_literal() ? {
	mut c := parse_and_compile('"abc"', 0)?
	// pc: 0, open-capture #1 's00'
  	// pc: 2, char 'a'
  	// pc: 3, char 'b'
  	// pc: 4, char 'c'
  	// pc: 5, close-capture
  	// pc: 6, end
	assert c.symbols.len() == 1
	assert c.symbols.get(0) == "*"
	assert c.code.len == 7
	assert c.code[0].opcode() == .open_capture
	assert c.code[1].int() == 0			// symbol at pos 0
	assert c.code[2].opcode() == .char
	assert c.code[2].ichar() == `a`
	assert c.code[3].opcode() == .char
	assert c.code[3].ichar() == `b`
	assert c.code[4].opcode() == .char
	assert c.code[4].ichar() == `c`
	assert c.code[5].opcode() == .close_capture
	assert c.code[6].opcode() == .end
}

fn test_literal_plus() ? {
	mut c := parse_and_compile('"a"+', 0)?
	// pc: 0, open-capture #1 's01'
  	// pc: 2, char 'a'
  	// pc: 3, span [(98)]		// TODO span seems large (and a bit slow) for this use case
  	// pc: 12, close-capture
  	// pc: 13, end
	assert c.symbols.len() == 1
	assert c.symbols.get(0) == "*"
	assert c.code.len == 14
	assert c.code[0].opcode() == .open_capture
	assert c.code[1].int() == 0			// symbol at pos 0
	assert c.code[2].opcode() == .char
	assert c.code[2].ichar() == `a`
	assert c.code[3].opcode() == .span
	assert c.code.to_charset(4).is_equal(rt.new_charset_with_byte(`a`))
	assert c.code[12].opcode() == .close_capture
	assert c.code[13].opcode() == .end
}