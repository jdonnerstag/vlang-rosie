Thursday, July 26, 2018

Yesterday, bin/rosie ('sepcomp3' branch, with rpeg) and match.c both
appeared to be slower than Rosie v1.0.0.  But, rpeg was being compiled
without any optimizations.  The latest rpeg (6c76181) has -O2 in its
Makefile.  The tests below use that version of rpeg, compiled without
DEBUG.

SUMMARY:

  The dev rosie ('sepcomp3', with rpeg) takes 71% of the time needed
  by Rosie v1.0.0 for the json/all.things/syslog10k test.
  ==> 29% speedup

  The sample matching program, match.c, using the same rpeg, takes 55%
  of the time needed by Rosie v1.0.0.
  ==> 45% speedup
  
  The sample matching program, match.c, using the same rpeg, takes 78%
  of the time needed by the dev rosie ('sepcomp3', with rpeg).
  ==> 22% speedup

ANALYSIS:

  These tests were quite limited, consisting of 61 executions each,
  and performed using a single compiler on a single machine.  However...

  The new matching code (rpeg), contains roughly 850 lines of new C
  code, written specifically for this refactoring.  By contrast, the
  code remaining from lpeg is about 550 lines (all in vm.c).

  So it appears that the new code performs well in comparison to the
  code it replaced (the ktable and stack ADTS, and the recursive
  capture processing in lpeg).

  Most dramatic is the nearly doubling in performance seen when
  comparing match.c to Rosie v1.0.0.  The small match.c program does
  not compile a pattern, which contributes to the gain.

  Running the same tests using /dev/null as the input file measures
  program startup time plus compilation time for the all.things
  pattern.  This amounts to a cost of around 0.71 seconds (user time)
  paid by Rosie v1.0.0 and 0.174s for dev rosie ('sepcomp3'), which
  have the same compiler.  (The small difference may be due to
  different startup costs of lpeg versus rpeg, or it may be
  statistically insignificant.)

  By contrast, the match.c program is simply reading the compiled
  pattern from a file, which takes no measurable time.

  Subtracting the startup and compilation time, we get this comparison
  of run-time match speed:
  
  Time needed by Rosie v1.0.0 after startup/compilation is 1.089s
  (1.260 - 0.171).  This is our baseline for matching 10k input records.

  Time needed by rosie ('sepcomp3', with rpeg) after startup and
  compilation is 0.72s (0.894 - 0.174). 
  0.72s versus 1.089s  ==> 66% of baseline time, or 34% speedup

  Time needed by match.c, with insignificant startup time and no
  compilation, is 0.693s.
  0.693s versus 1.089s ==> 64% of baseline time, or 36% speedup

CONCLUSIONS:

  (1) For the pattern all.things, and for this syslog-style input
  data, which contains dates, ipv4 addresses, and other constructs
  recognized by all.things, the new rpeg implementation gives a
  measurable improvement in speed, needing roughly 2/3 of the baseline
  Rosie v1.0.0 time.

  ACTION: We should not spend time optimizing the new rpeg run-time.
  Instead, we should focus on the Rosie compiler, which generates very
  large binary pattern code (because it inlines every sub-pattern).
  E.g. the all.things.rplx file has 196k vm instructions!

  (2) The startup and compilation time for a large pattern like
  all.things can be around 0.17s, which is large.  The match.c program
  represents the effect of separate compilation: the all.things.rplx
  file was generated by Rosie ahead of time, and simply read by
  match.c, taking an immeasurably small amount of time (by the
  capability of /usr/bin/time).

  ACTION: Clearly, the ahead-of-time compilation technique is valuable
  from a time performance perspective.  (Also, a typical run of
  match.c has a peak RSS of 2MB, compared to 48MB for Rosie v1.0.0.
  So, space performance is dramatically better.)  So the action item
  here is to enhance Rosie to automatically save compiled patterns and
  to use those when possible, instead of recompiling.

--

Compiler:
    clangApple LLVM version 9.1.0 (clang-902.0.39.2)
    Target: x86_64-apple-darwin17.7.0
    Thread model: posix
    InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin

OS:
    OS X 10.13.6 (17G65)

MacBook Pro Hardware Overview:
    Model Name:	MacBook Pro
    Model Identifier:	MacBookPro12,1
    Processor Name:	Intel Core i5
    Processor Speed:	2.9 GHz
    Number of Processors:	1
    Total Number of Cores:	2
    L2 Cache (per Core):	256 KB
    L3 Cache:	3 MB
    Memory:	8 GB
    Boot ROM Version:	MBP121.0177.B00
    SMC Version (system):	2.28f7


DATA from perf-20180726-* files in rpeg repository:

rosie match -o json all.things ../rpeg/unittest/perf/data/syslog10k
d2484fff8280da4864a62f5f3e5297cbb9217193
N.B. Commit level meaningless, since we are running rosie 1.0.0 from /usr/local:
    [~/Projects/rosie-pattern-language/rosie]$ which rosie
    /usr/local/bin/rosie
    [~/Projects/rosie-pattern-language/rosie]$ rosie version
    1.0.0
    [~/Projects/rosie-pattern-language/rosie]$
User mean 1.260, median 1.26

bin/rosie match -o json all.things ../rpeg/unittest/perf/data/syslog10k
e218dbbdff506475c921c637335ce603328a165d
User mean 0.894, median 0.87

./match data/all.things.rplx perf/data/syslog10k
6c76181536e8c185bac78b68bcead3106733abae
User mean 0.693, median 0.68

Testing compilation only:

rosie match -o json all.things /dev/null
e218dbbdff506475c921c637335ce603328a165d
User mean 0.171, median 0.17

bin/rosie match -o json all.things /dev/null
e218dbbdff506475c921c637335ce603328a165d
User mean 0.174, median 0.17

./match data/all.things.rplx /dev/null
6c76181536e8c185bac78b68bcead3106733abae
User mean 0.000, median 0.00

